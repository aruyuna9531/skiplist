# 作者碎碎念

这个跳表是我在前司工作时某些功能用的那个sortset底层的数据结构。

因为辣个游戏跟原神啥的不一样，是喜欢做排行榜的，于是各种榜的存在需要一个有序数组做支撑，于是有同事参考了redis的zset弄了一个sortset出来（包含了zset的常用操作如zadd、zrange、zrank等，反向的也有，略）。

后来另外还有各种包括什么有序队列（计时器轮转/生产队列）还有些什么需要按特定顺序展示的功能（诸如邮件未读在前）也用到了这个sortset。

这个sortset逻辑上没有问题，确实有序，数据层的数据增删查改都没问题，但是各大索引层的生成与消失有时候看着挺别扭的（诸如船新sortset就加了3个元素结果底层结构是3层链表每层3个元素，值相互一一对应的情况，可能是触发了最坏情况，这波不但效率等于链表，空间消耗更是链表几倍，不太像一个跳表能干出来的操作）。当然优化是不可能优化的，本着结果正确就不动的原则，它虽然看着别扭但确实仍然是一个“合理”且“结果符合期望”的跳表。

所以目前整理经验的时候，抽空尝试写了一下*我觉得*相对来讲看着没那么别扭的跳表。

插入的基本思路是：直接自顶向下定位到要插入的位置，先把它插到数据层。然后判定上层能索引到插入节点的那个索引节点，如果它在管的节点数（即它和它的next之间的下层节点数）超过一定值就在它们正中间的头顶生成一个新的索引节点，使链表查找复杂度基本趋近对数。

当然这可能会引出2个问题：（1）还不存在上一层索引层的时候的处理；（2）刚生成的索引节点又使得管这个索引节点的上层索引节点满了。

不过这些都是建立一个跳表必须要解决的，所以接下来思路也差不多

删除的基本思路：自顶向下找到第一个等于该元素的索引层，它的下面全都要做改动。不同思路处理方式也不一样，但基本都合理。

我这里是底层数据层直接拿掉这个节点，但它头上的所有索引节点有2种处理方式：（1）往左边或者右边挪个位置（取决于哪边在管的note数更多）；（2）直接删掉。目前代码里做了一下平衡，即如果删掉这个点的话它后面那个管的节点数如果过多，那就不删，而是往左或往右挪个位子（当然如果挪一下直接跟隔壁撞上了就直接拿掉）。不太多的话就直接拿掉就行，基本不影响查询效率。

插入时生成索引节点的阈值（createIndexGap）和删除节点时索引节点的调整阈值，我都用了同一个数值，用不同的值应该也行，我就是图个方便，也还没具体分析这两个值什么情况下最佳（代码里的5是随便写的，除了1或者2会导致出现最上面讲的那种别扭的结构之外，3以上应该都ok，取3的话体积可能仍然很大不过应该还行。最坏情况下所有元素完全按顺序插入，除了末尾之外所有节点的linkNodes值应该都是阈值的一半。

然后为了解决计算rank的问题，肯定不是说每个节点都维护一个rank值，否则到时候频繁在头部插入元素，那整表都得改rank值，就把插入退化到O(N)了

这里就引入一个span值，即它和它的同层下一个节点之间一共有几个最底层数据节点。到时候插入删除一个数据只需要维护管到它自己的索引节点的span就行了，其他都不用动。如果出现新增索引节点的情况，那新节点的后置的span分一些出去给新节点就行了，其他都不用操作。索引节点删除的时候甚至所有的span都不用动。

这样，查询某个元素的rank的时候，索引平级跳的话rank直接加上跳出去的索引的span值就行了。

目前这个跳表不支持完全值相等的多个元素出现在跳表里，主要是怕hold不住一长串全是等值元素的情况（等值索引下面指下来可能前面后面都有一串相同值的东西，算rank也不好算。之前项目里那个跳表也没支持这个）

最后还有一个就是：为什么当时项目里要手撸一个sortset（也可能是github找来的但我没找到出处先认为是同事手撸的）实现有序列表功能而不是直接使用redis的zset呢

答：项目没有使用redis，遇事不决加内存，内存读数据更快，数据也更容易定制化，redis的zset毕竟还是只有一个字符串key和一个数值score，序列化出唯一的key也是门学问（在前前司项目要用redis的时候踩过的坑）。